"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_events_1 = __importDefault(require("node:events"));
const node_url_1 = __importDefault(require("node:url"));
const node_crypto_1 = __importDefault(require("node:crypto"));
const node_stream_1 = __importStar(require("node:stream"));
const normalize_url_1 = __importDefault(require("normalize-url"));
const get_stream_1 = __importDefault(require("get-stream"));
const http_cache_semantics_1 = __importDefault(require("http-cache-semantics"));
const responselike_1 = __importDefault(require("responselike"));
const keyv_1 = __importDefault(require("keyv"));
const mimic_response_1 = __importDefault(require("mimic-response"));
const { Readable } = node_stream_1.default;
const CacheableRequest = function (request, cacheAdapter) {
    let cache = {};
    if (cacheAdapter instanceof keyv_1.default) {
        cache = cacheAdapter;
    }
    else {
        cache = new keyv_1.default({
            uri: (typeof cacheAdapter === 'string' && cacheAdapter) || '',
            store: typeof cacheAdapter !== 'string' && cacheAdapter,
            namespace: 'cacheable-request',
        });
    }
    return createCacheableRequest(request, cache);
};
function createCacheableRequest(request, cache) {
    return (options, cb) => {
        let url;
        if (typeof options === 'string') {
            url = normalizeUrlObject(node_url_1.default.parse(options));
            options = {};
        }
        else if (options instanceof node_url_1.default.URL) {
            url = normalizeUrlObject(node_url_1.default.parse(options.toString()));
            options = {};
        }
        else {
            const [pathname, ...searchParts] = (options.path || '').split('?');
            const search = searchParts.length > 0
                ? `?${searchParts.join('?')}`
                : '';
            url = normalizeUrlObject({ ...options, pathname, search });
        }
        options = {
            headers: {},
            method: 'GET',
            cache: true,
            strictTtl: false,
            automaticFailover: false,
            ...options,
            ...urlObjectToRequestOptions(url),
        };
        options.headers = Object.fromEntries(Object.entries(options.headers).map(([key, value]) => [key.toLowerCase(), value]));
        const ee = new node_events_1.default();
        const normalizedUrlString = (0, normalize_url_1.default)(node_url_1.default.format(url), {
            stripWWW: false,
            removeTrailingSlash: false,
            stripAuthentication: false,
        });
        let key = `${options.method}:${normalizedUrlString}`;
        // POST, PATCH, and PUT requests may be cached, depending on the response
        // cache-control headers. As a result, the body of the request should be
        // added to the cache key in order to avoid collisions.
        if (options.body && ['POST', 'PATCH', 'PUT'].includes(options.method)) {
            if (options.body instanceof Readable) {
                // Streamed bodies should completely skip the cache because they may
                // or may not be hashable and in either case the stream would need to
                // close before the cache key could be generated.
                options.cache = false;
            }
            else {
                key += `:${node_crypto_1.default.createHash('md5').update(options.body).digest('hex')}`;
            }
        }
        let revalidate = false;
        let madeRequest = false;
        const makeRequest = (options_) => {
            madeRequest = true;
            let requestErrored = false;
            let requestErrorCallback;
            const requestErrorPromise = new Promise(resolve => {
                requestErrorCallback = () => {
                    if (!requestErrored) {
                        requestErrored = true;
                        resolve();
                    }
                };
            });
            const handler = (response) => {
                if (revalidate && !options_.forceRefresh) {
                    response.status = response.statusCode;
                    const revalidatedPolicy = http_cache_semantics_1.default.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);
                    if (!revalidatedPolicy.modified) {
                        const headers = revalidatedPolicy.policy.responseHeaders();
                        response = new responselike_1.default(revalidate.statusCode, headers, revalidate.body, revalidate.url);
                        response.cachePolicy = revalidatedPolicy.policy;
                        response.fromCache = true;
                    }
                }
                if (!response.fromCache) {
                    response.cachePolicy = new http_cache_semantics_1.default(options_, response, options_);
                    response.fromCache = false;
                }
                let clonedResponse;
                if (options_.cache && response.cachePolicy.storable()) {
                    clonedResponse = cloneResponse(response);
                    (async () => {
                        try {
                            const bodyPromise = get_stream_1.default.buffer(response);
                            await Promise.race([
                                requestErrorPromise,
                                new Promise(resolve => response.once('end', resolve)), // eslint-disable-line no-promise-executor-return
                            ]);
                            const body = await bodyPromise;
                            const value = {
                                cachePolicy: response.cachePolicy.toObject(),
                                url: response.url,
                                statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                                body,
                            };
                            let ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;
                            if (options_.maxTtl) {
                                ttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;
                            }
                            await cache.set(key, value, ttl);
                        }
                        catch (error) {
                            ee.emit('error', new CacheableRequest.CacheError(error));
                        }
                    })();
                }
                else if (options_.cache && revalidate) {
                    (async () => {
                        try {
                            await cache.delete(key);
                        }
                        catch (error) {
                            ee.emit('error', new CacheableRequest.CacheError(error));
                        }
                    })();
                }
                ee.emit('response', clonedResponse || response);
                if (typeof cb === 'function') {
                    cb(clonedResponse || response);
                }
            };
            try {
                const request_ = request(options_, handler);
                request_.once('error', requestErrorCallback);
                request_.once('abort', requestErrorCallback);
                ee.emit('request', request_);
            }
            catch (error) {
                ee.emit('error', new CacheableRequest.RequestError(error));
            }
        };
        (async () => {
            const get = async (options_) => {
                await Promise.resolve();
                const cacheEntry = options_.cache ? await cache.get(key) : undefined;
                if (typeof cacheEntry === 'undefined') {
                    makeRequest(options_);
                    return;
                }
                const policy = http_cache_semantics_1.default.fromObject(cacheEntry.cachePolicy);
                if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {
                    const headers = policy.responseHeaders();
                    const response = new responselike_1.default(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
                    response.cachePolicy = policy;
                    response.fromCache = true;
                    ee.emit('response', response);
                    if (typeof cb === 'function') {
                        cb(response);
                    }
                }
                else {
                    revalidate = cacheEntry;
                    options_.headers = policy.revalidationHeaders(options_);
                    makeRequest(options_);
                }
            };
            const errorHandler = (error) => ee.emit('error', new CacheableRequest.CacheError(error));
            cache.once?.('error', errorHandler);
            ee.on('error', () => cache.removeListener?.('error', errorHandler));
            ee.on('response', () => cache.removeListener?.('error', errorHandler));
            try {
                await get(options);
            }
            catch (error) {
                if (options.automaticFailover && !madeRequest) {
                    makeRequest(options);
                }
                ee.emit('error', new CacheableRequest.CacheError(error));
            }
        })();
        return ee;
    };
}
function cloneResponse(response) {
    const clone = new node_stream_1.PassThrough({ autoDestroy: false });
    (0, mimic_response_1.default)(response, clone);
    return response.pipe(clone);
}
function urlObjectToRequestOptions(url) {
    const options = { ...url };
    options.path = `${url.pathname || '/'}${url.search || ''}`;
    delete options.pathname;
    delete options.search;
    return options;
}
function normalizeUrlObject(url) {
    // If url was parsed by url.parse or new URL:
    // - hostname will be set
    // - host will be hostname[:port]
    // - port will be set if it was explicit in the parsed string
    // Otherwise, url was from request options:
    // - hostname or host may be set
    // - host shall not have port encoded
    return {
        protocol: url.protocol,
        auth: url.auth,
        hostname: url.hostname || url.host || 'localhost',
        port: url.port,
        pathname: url.pathname,
        search: url.search,
    };
}
CacheableRequest.RequestError = class extends Error {
    constructor(error) {
        super(error.message);
        this.name = 'RequestError';
        Object.assign(this, error);
    }
};
CacheableRequest.CacheError = class extends Error {
    constructor(error) {
        super(error.message);
        this.name = 'CacheError';
        Object.assign(this, error);
    }
};
exports.default = CacheableRequest;
//# sourceMappingURL=index.js.map